inspect({object}, {options})                                   *vim.inspect()*
                Return a human-readable representation of the given object.

                See also: 
                    https://github.com/kikito/inspect.lua
                    https://github.com/mpeterv/vinspect


make_meta_accessor({get}, {set}, {del})             *vim.make_meta_accessor()*
                TODO: Documentation


paste({lines}, {phase})                                          *vim.paste()*
                Paste handler, invoked by |nvim_paste()| when a conforming UI
                (such as the |TUI|) pastes text into the editor.

                Example: To remove ANSI color codes when pasting:

                 vim.paste = (function(overridden)
                   return function(lines, phase)
                     for i,line in ipairs(lines) do
                       -- Scrub ANSI color codes from paste input.
                       lines[i] = line:gsub('\27%[[0-9;mK]+', '')
                     end
                     overridden(lines, phase)
                   end
                 end)(vim.paste)
 

                Parameters: 
                    {lines}  |readfile()|-style list of lines to paste.
                             |channel-lines|
                    {phase}  -1: "non-streaming" paste: the call contains all
                             lines. If paste is "streamed", `phase` indicates the stream state:
                             • 1: starts the paste (exactly once)
                             • 2: continues the paste (zero or more times)
                             • 3: ends the paste (exactly once)

                Return: 
                    false if client should cancel the paste.

                See also: 
                    |paste|


schedule_wrap({cb})                                      *vim.schedule_wrap()*
                Defers callback `cb` until the Nvim API is safe to call.

                See also: 
                    |lua-loop-callbacks|
                    |vim.schedule()|
                    |vim.in_fast_event()|





deep_equal({a}, {b})                                        *vim.deep_equal()*
                TODO: Documentation


deepcopy({orig})                                              *vim.deepcopy()*
                Returns a deep copy of the given object. Non-table objects are
                copied as in a typical Lua assignment, whereas table objects
                are copied recursively. Functions are naively copied, so
                functions in the copied table point to the same functions as
                those in the input table. Userdata and threads are not copied
                and will throw an error.

                Parameters: 
                    {orig}  Table to copy

                Return: 
                    New table of copied keys and (nested) values.


endswith({s}, {suffix})                                       *vim.endswith()*
                Tests if `s` ends with `suffix` .

                Parameters: 
                    {s}       (string) a string
                    {suffix}  (string) a suffix

                Return: 
                    (boolean) true if `suffix` is a suffix of s


gsplit({s}, {sep}, {plain})                                     *vim.gsplit()*
                Splits a string at each instance of a separator.

                Parameters: 
                    {s}      String to split
                    {sep}    Separator string or pattern
                    {plain}  If `true` use `sep` literally (passed to
                             String.find)

                Return: 
                    Iterator over the split components

                See also: 
                    |vim.split()|
                    https://www.lua.org/pil/20.2.html
	http://lua-users.org/wiki/StringLibraryTutorial


is_callable({f})                                           *vim.is_callable()*
                Returns true if object `f` can be called as a function.

                Parameters: 
                    {f}  Any object

                Return: 
                    true if `f` is callable, else false


is_valid({opt})                                               *vim.is_valid()*
                TODO: Documentation


list_extend({dst}, {src}, {start}, {finish})               *vim.list_extend()*
                Extends a list-like table with the values of another list-like
                table.

                NOTE: This mutates dst!

                Parameters: 
                    {dst}     list which will be modified and appended to.
                    {src}     list from which values will be inserted.
                    {start}   Start index on src. defaults to 1
                    {finish}  Final index on src. defaults to #src

                Return: 
                    dst

                See also: 
                    |vim.tbl_extend()|


pesc({s})                                                         *vim.pesc()*
                Escapes magic chars in a Lua pattern.

                Parameters: 
                    {s}  String to escape

                Return: 
                    %-escaped pattern string

                See also: 
                    https://github.com/rxi/lume


split({s}, {sep}, {plain})                                       *vim.split()*
                Splits a string at each instance of a separator.

                Examples:
                 split(":aa::b:", ":")     --> {'','aa','','b',''}
                 split("axaby", "ab?")     --> {'','x','y'}
                 split(x*yz*o, "*", true)  --> {'x','yz','o'}
 

                Parameters: 
                    {s}      String to split
                    {sep}    Separator string or pattern
                    {plain}  If `true` use `sep` literally (passed to
                             String.find)

                Return: 
                    List-like table of the split components.

                See also: 
                    |vim.gsplit()|


startswith({s}, {prefix})                                   *vim.startswith()*
                Tests if `s` starts with `prefix` .

                Parameters: 
                    {s}       (string) a string
                    {prefix}  (string) a prefix

                Return: 
                    (boolean) true if `prefix` is a prefix of s


tbl_add_reverse_lookup({o})                     *vim.tbl_add_reverse_lookup()*
                Add the reverse lookup values to an existing table. For
                example: tbl_add_reverse_lookup { A = 1 } == { [1] = 'A , A = 1 }`

                Parameters: 
                    {o}  table The table to add the reverse to.


tbl_contains({t}, {value})                                *vim.tbl_contains()*
                Checks if a list-like (vector) table contains `value` .

                Parameters: 
                    {t}      Table to check
                    {value}  Value to compare

                Return: 
                    true if `t` contains `value`


tbl_count({t})                                               *vim.tbl_count()*
                Counts the number of non-nil values in table `t` .


    vim.tbl_count({ a=1, b=2 }) => 2
    vim.tbl_count({ 1, 2 }) => 2
 

                Parameters: 
                    {t}  Table

                Return: 
                    Number that is the number of the value in table

                See also: 
                    https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua


tbl_deep_extend({behavior}, {...})                     *vim.tbl_deep_extend()*
                Merges recursively two or more map-like tables.

                Parameters: 
                    {behavior}  Decides what to do if a key is found in more
                                than one map:
                                • "error": raise an error
                                • "keep": use value from the leftmost map
                                • "force": use value from the rightmost map
                    {...}       Two or more map-like tables.

                See also: 
                    |tbl_extend()|


tbl_extend({behavior}, {...})                               *vim.tbl_extend()*
                Merges two or more map-like tables.

                Parameters: 
                    {behavior}  Decides what to do if a key is found in more
                                than one map:
                                • "error": raise an error
                                • "keep": use value from the leftmost map
                                • "force": use value from the rightmost map
                    {...}       Two or more map-like tables.

                See also: 
                    |extend()|


tbl_filter({func}, {t})                                     *vim.tbl_filter()*
                Filter a table using a predicate function

                Parameters: 
                    {func}  function or callable table
                    {t}     table


tbl_flatten({t})                                           *vim.tbl_flatten()*
                Creates a copy of a list-like table such that any nested
                tables are "unrolled" and appended to the result.

                Parameters: 
                    {t}  List-like table

                Return: 
                    Flattened copy of the given list-like table.

                See also: 
                    Fromhttps://github.com/premake/premake-core/blob/master/src/base/table.lua


tbl_isempty({t})                                           *vim.tbl_isempty()*
                Checks if a table is empty.

                Parameters: 
                    {t}  Table to check

                See also: 
                    https://github.com/premake/premake-core/blob/master/src/base/table.lua


tbl_islist({t})                                             *vim.tbl_islist()*
                Tests if a Lua table can be treated as an array.

                Empty table `{}` is assumed to be an array, unless it was
                created by |vim.empty_dict()| or returned as a dict-like |API|
                or Vimscript result, for example from |rpcrequest()| or
                |vim.fn|.

                Parameters: 
                    {t}  Table

                Return: 
                    `true` if array-like table, else `false` .


tbl_keys({t})                                                 *vim.tbl_keys()*
                Return a list of all keys used in a table. However, the order
                of the return table of keys is not guaranteed.

                Parameters: 
                    {t}  Table

                Return: 
                    list of keys

                See also: 
                    Fromhttps://github.com/premake/premake-core/blob/master/src/base/table.lua


tbl_map({func}, {t})                                           *vim.tbl_map()*
                Apply a function to all values of a table.

                Parameters: 
                    {func}  function or callable table
                    {t}     table


tbl_values({t})                                             *vim.tbl_values()*
                Return a list of all values used in a table. However, the
                order of the return table of values is not guaranteed.

                Parameters: 
                    {t}  Table

                Return: 
                    list of values


trim({s})                                                         *vim.trim()*
                Trim whitespace (Lua pattern "%s") from both sides of a
                string.

                Parameters: 
                    {s}  String to trim

                Return: 
                    String with whitespace removed from its beginning and end

                See also: 
                    https://www.lua.org/pil/20.2.html


validate({opt})                                               *vim.validate()*
                Validates a parameter specification (types and values).

                Usage example:

                  function user.new(name, age, hobbies)
                    vim.validate{
                      name={name, 'string'},
                      age={age, 'number'},
                      hobbies={hobbies, 'table'},
                    }
                    ...
                  end
 

                Examples with explicit argument values (can be run directly):

                  vim.validate{arg1={{'foo'}, 'table'}, arg2={'foo', 'string'}}
                     => NOP (success)
 

    vim.validate{arg1={1, 'table'}}
       => error('arg1: expected table, got number')
 

    vim.validate{arg1={3, function(a) return (a % 2) == 0 end, 'even number'}}
       => error('arg1: expected even number, got 3')
 

                Parameters: 
                    {opt}  Map of parameter names to validations. Each key is
                           a parameter name; each value is a tuple in one of
                           these forms:
                           1. (arg_value, type_name, optional)
                              • arg_value: argument value
                              • type_name: string type name, one of: ("table",
                                "t", "string", "s", "number", "n", "boolean",
                                "b", "function", "f", "nil", "thread",
                                "userdata")
                              • optional: (optional) boolean, if true, `nil`
                                is valid

                           2. (arg_value, fn, msg)
                              • arg_value: argument value
                              • fn: any function accepting one argument,
                                returns true if and only if the argument is
                                valid. Can optionally return an additional
                                informative error message as the second
                                returned value.
                              • msg: (optional) error string if validation
                                fails


uri_from_bufnr({bufnr})                                 *vim.uri_from_bufnr()*
                Get a URI from a bufnr

                Parameters: 
                    {bufnr}  (number): Buffer number

                Return: 
                    URI


uri_from_fname({path})                                  *vim.uri_from_fname()*
                Get a URI from a file path.

                Parameters: 
                    {path}  (string): Path to file

                Return: 
                    URI


uri_to_bufnr({uri})                                       *vim.uri_to_bufnr()*
                Return or create a buffer for a uri.

                Parameters: 
                    {uri}  (string): The URI

                Return: 
                    bufnr.
                Note:
                    Creates buffer but does not load it


uri_to_fname({uri})                                       *vim.uri_to_fname()*
                Get a filename from a URI

                Parameters: 
                    {uri}  (string): The URI

                Return: 
                    Filename
