{
 "leftTitle": "4. Builtin Functions",
 "rightTitle": "vim-function* *functions",
 "description": "",
 "data": [
  {
   "type": "func",
   "name": "abs",
   "description": "Return the absolute value of {expr}.  When {expr} evaluates to\n\t\ta |Float| abs() returns a |Float|.  When {expr} can be\n\t\tconverted to a |Number| abs() returns a |Number|.  Otherwise\n\t\tabs() gives an error message and returns -1.\n\t\tExamples: >\n\t\t\techo abs(1.456)\n<\t\t\t1.456  >\n\t\t\techo abs(-5.456)\n<\t\t\t5.456  >\n\t\t\techo abs(-4)\n<\t\t\t4",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "acos",
   "description": "Return the arc cosine of {expr} measured in radians, as a\n\t\t|Float| in the range of [0, pi].\n\t\t{expr} must evaluate to a |Float| or a |Number| in the range\n\t\t[-1, 1].\n\t\tExamples: >\n\t\t\t:echo acos(0)\n<\t\t\t1.570796 >\n\t\t\t:echo acos(-0.5)\n<\t\t\t2.094395",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "add",
   "description": "Append the item {expr} to |List| {list}.  Returns the\n\t\tresulting |List|.  Examples: >\n\t\t\t:let alist = add([1, 2, 3], item)\n\t\t\t:call add(mylist, \"woodstock\")\n<\t\tNote that when {expr} is a |List| it is appended as a single\n\t\titem.  Use |extend()| to concatenate |Lists|.\n\t\tUse |insert()| to add an item at another position.",
   "argsType": "{list}, {expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "and",
   "description": "Bitwise AND on the two arguments.  The arguments are converted\n\t\tto a number.  A List, Dict or Float argument causes an error.\n\t\tExample: >\n\t\t\t:let flag = and(bits, 0x80)",
   "argsType": "{expr}, {expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "api_info",
   "description": "Returns Dictionary of |api-metadata|.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "append",
   "description": "When {text} is a |List|: Append each item of the |List| as a\n\t\ttext line below line {lnum} in the current buffer.\n\t\tOtherwise append {text} as one text line below line {lnum} in\n\t\tthe current buffer.\n\t\t{lnum} can be zero to insert a line before the first one.\n\t\tReturns 1 for failure ({lnum} out of range or out of memory),\n\t\t0 for success.  Example: >\n\t\t\t:let failed = append(line('$'), \"# THE END\")\n\t\t\t:let failed = append(0, [\"Chapter 1\", \"the beginning\"])",
   "argsType": "{lnum}, {text}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "appendbufline",
   "description": "Like |append()| but append the text in buffer {expr}.",
   "argsType": "{expr}, {lnum}, {text}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "argc",
   "description": "argc([{winid}])\n\t\tThe result is the number of files in the argument list.  See\n\t\t|arglist|.\n\t\tIf {winid} is not supplied, the argument list of the current\n\t\twindow is used.\n\t\tIf {winid} is -1, the global argument list is used.\n\t\tOtherwise {winid} specifies the window of which the argument\n\t\tlist is used: either the window number or the window ID.\n\t\tReturns -1 if the {winid} argument is invalid.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "argidx",
   "description": "argidx()\tThe result is the current index in the argument list.  0 is\n\t\tthe first file.  argc() - 1 is the last one.  See |arglist|.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "arglistid",
   "description": "arglistid([{winnr} [, {tabnr}]])\n\t\tReturn the argument list ID.  This is a number which\n\t\tidentifies the argument list being used.  Zero is used for the\n\t\tglobal argument list.  See |arglist|.\n\t\tReturns -1 if the arguments are invalid.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "argv",
   "description": "argv([{nr} [, {winid}])\n\t\tThe result is the {nr}th file in the argument list.  See\n\t\t|arglist|.  \"argv(0)\" is the first one.  Example: >\n\t:let i = 0\n\t:while i < argc()\n\t:  let f = escape(fnameescape(argv(i)), '.')\n\t:  exe 'amenu Arg.' . f . ' :e ' . f . '<CR>'\n\t:  let i = i + 1\n\t:endwhile\n<\t\tWithout the {nr} argument, or when {nr} is -1, a |List| with\n\t\tthe whole |arglist| is returned.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_beeps",
   "description": "Run {cmd} and add an error message to |v:errors| if it does\n\t\tNOT produce a beep or visual bell.\n\t\tAlso see |assert_fails()| and |assert-return|.",
   "argsType": "{cmd}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_equal",
   "description": "assert_equal({expected}, {actual}, [, {msg}])\n\t\tWhen {expected} and {actual} are not equal an error message is\n\t\tadded to |v:errors| and 1 is returned.  Otherwise zero is\n\t\treturned |assert-return|.\n\t\tThere is no automatic conversion, the String \"4\" is different\n\t\tfrom the Number 4.  And the number 4 is different from the\n\t\tFloat 4.0.  The value of 'ignorecase' is not used here, case\n\t\talways matters.\n\t\tWhen {msg} is omitted an error in the form \"Expected\n\t\t{expected} but got {actual}\" is produced.\n\t\tExample: >\n\tassert_equal('foo', 'bar')\n<\t\tWill result in a string to be added to |v:errors|:\n\ttest.vim line 12: Expected 'foo' but got 'bar' ~",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_equalfile",
   "description": "assert_equalfile({fname-one}, {fname-two} [, {msg}])\n\t\tWhen the files {fname-one} and {fname-two} do not contain\n\t\texactly the same text an error message is added to |v:errors|.\n\t\tAlso see |assert-return|.\n\t\tWhen {fname-one} or {fname-two} does not exist the error will\n\t\tmention that.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_exception",
   "description": "When v:exception does not contain the string {error} an error\n\t\tmessage is added to |v:errors|.  Also see |assert-return|.\n\t\tThis can be used to assert that a command throws an exception.\n\t\tUsing the error number, followed by a colon, avoids problems\n\t\twith translations: >\n\t\t\ttry\n\t\t\t  commandthatfails\n\t\t\t  call assert_false(1, 'command should have failed')\n\t\t\tcatch\n\t\t\t  call assert_exception('E492:')\n\t\t\tendtry",
   "argsType": "{error} [, {msg}]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_fails",
   "description": "Run {cmd} and add an error message to |v:errors| if it does\n\t\tNOT produce an error.  Also see |assert-return|.\n\t\tWhen {error} is given it must match in |v:errmsg|.\n\t\tNote that beeping is not considered an error, and some failing\n\t\tcommands only beep.  Use |assert_beeps()| for those.",
   "argsType": "{cmd} [, {error} [, {msg}]]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_false",
   "description": "When {actual} is not false an error message is added to\n\t\t|v:errors|, like with |assert_equal()|.\n\t\tAlso see |assert-return|.\n\t\tA value is false when it is zero or |v:false|. When \"{actual}\"\n\t\tis not a number or |v:false| the assert fails.\n\t\tWhen {msg} is omitted an error in the form\n\t\t\"Expected False but got {actual}\" is produced.",
   "argsType": "{actual} [, {msg}]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_inrange",
   "description": "This asserts number and |Float| values.  When {actual}  is lower\n\t\tthan {lower} or higher than {upper} an error message is added\n\t\tto |v:errors|.  Also see |assert-return|.\n\t\tWhen {msg} is omitted an error in the form\n\t\t\"Expected range {lower} - {upper}, but got {actual}\" is\n\t\tproduced.",
   "argsType": "{lower}, {upper}, {actual} [, {msg}]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_match",
   "description": "assert_match({pattern}, {actual} [, {msg}])\n\t\tWhen {pattern} does not match {actual} an error message is\n\t\tadded to |v:errors|.  Also see |assert-return|.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_notequal",
   "description": "assert_notequal({expected}, {actual} [, {msg}])\n\t\tThe opposite of `assert_equal()`: add an error message to\n\t\t|v:errors| when {expected} and {actual} are equal.\n\t\tAlso see |assert-return|.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_notmatch",
   "description": "assert_notmatch({pattern}, {actual} [, {msg}])\n\t\tThe opposite of `assert_match()`: add an error message to\n\t\t|v:errors| when {pattern} matches {actual}.\n\t\tAlso see |assert-return|.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_report",
   "description": "Report a test failure directly, using {msg}.\n\t\tAlways returns one.",
   "argsType": "{msg}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "assert_true",
   "description": "When {actual} is not true an error message is added to\n\t\t|v:errors|, like with |assert_equal()|.\n\t\tAlso see |assert-return|.\n\t\tA value is |TRUE| when it is a non-zero number or |v:true|.\n\t\tWhen {actual} is not a number or |v:true| the assert fails.\n\t\tWhen {msg} is omitted an error in the form \"Expected True but\n\t\tgot {actual}\" is produced.",
   "argsType": "{actual} [, {msg}]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "asin",
   "description": "Return the arc sine of {expr} measured in radians, as a |Float|\n\t\tin the range of [-pi/2, pi/2].\n\t\t{expr} must evaluate to a |Float| or a |Number| in the range\n\t\t[-1, 1].\n\t\tExamples: >\n\t\t\t:echo asin(0.8)\n<\t\t\t0.927295 >\n\t\t\t:echo asin(-0.5)\n<\t\t\t-0.523599",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "atan",
   "description": "Return the principal value of the arc tangent of {expr}, in\n\t\tthe range [-pi/2, +pi/2] radians, as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo atan(100)\n<\t\t\t1.560797 >\n\t\t\t:echo atan(-4.01)\n<\t\t\t-1.326405",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "atan2",
   "description": "Return the arc tangent of {expr1} / {expr2}, measured in\n\t\tradians, as a |Float| in the range [-pi, pi].\n\t\t{expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo atan2(-1, 1)\n<\t\t\t-0.785398 >\n\t\t\t:echo atan2(1, -1)\n<\t\t\t2.356194",
   "argsType": "{expr1}, {expr2}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "browse",
   "description": "browse({save}, {title}, {initdir}, {default})\n\t\tPut up a file requester.  This only works when \"has(\"browse\")\"\n\t\treturns |TRUE| (only in some GUI versions).\n\t\tThe input fields are:\n\t\t    {save}\twhen |TRUE|, select file to write\n\t\t    {title}\ttitle for the requester\n\t\t    {initdir}\tdirectory to start browsing in\n\t\t    {default}\tdefault file name\n\t\tWhen the \"Cancel\" button is hit, something went wrong, or\n\t\tbrowsing is not possible, an empty string is returned.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "browsedir",
   "description": "browsedir({title}, {initdir})\n\t\tPut up a directory requester.  This only works when\n\t\t\"has(\"browse\")\" returns |TRUE| (only in some GUI versions).\n\t\tOn systems where a directory browser is not supported a file\n\t\tbrowser is used.  In that case: select a file in the directory\n\t\tto be used.\n\t\tThe input fields are:\n\t\t    {title}\ttitle for the requester\n\t\t    {initdir}\tdirectory to start browsing in\n\t\tWhen the \"Cancel\" button is hit, something went wrong, or\n\t\tbrowsing is not possible, an empty string is returned.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "bufadd",
   "description": "Add a buffer to the buffer list with {name}.\n\t\tIf a buffer for file {name} already exists, return that buffer\n\t\tnumber.  Otherwise return the buffer number of the newly\n\t\tcreated buffer.  When {name} is an empty string then a new\n\t\tbuffer is always created.\n\t\tThe buffer will not have' 'buflisted' set.",
   "argsType": "{name}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "bufexists",
   "description": "The result is a Number, which is |TRUE| if a buffer called\n\t\t{expr} exists.\n\t\tIf the {expr} argument is a number, buffer numbers are used.\n\t\tNumber zero is the alternate buffer for the current window.",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "buflisted",
   "description": "The result is a Number, which is |TRUE| if a buffer called\n\t\t{expr} exists and is listed (has the 'buflisted' option set).\n\t\tThe {expr} argument is used like with |bufexists()|.",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "bufload",
   "description": "Ensure the buffer {expr} is loaded.  When the buffer name\n\t\trefers to an existing file then the file is read.  Otherwise\n\t\tthe buffer will be empty.  If the buffer was already loaded\n\t\tthen there is no change.\n\t\tIf there is an existing swap file for the file of the buffer,\n\t\tthere will be no dialog, the buffer will be loaded anyway.\n\t\tThe {expr} argument is used like with |bufexists()|.",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "bufloaded",
   "description": "The result is a Number, which is |TRUE| if a buffer called\n\t\t{expr} exists and is loaded (shown in a window or hidden).\n\t\tThe {expr} argument is used like with |bufexists()|.",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "bufname",
   "description": "The result is the name of a buffer, as it is displayed by the\n\t\t\":ls\" command.\n+\t\tIf {expr} is omitted the current buffer is used.\n\t\tIf {expr} is a Number, that buffer number's name is given.\n\t\tNumber zero is the alternate buffer for the current window.\n\t\tIf {expr} is a String, it is used as a |file-pattern| to match\n\t\twith the buffer names.  This is always done like 'magic' is\n\t\tset and 'cpoptions' is empty.  When there is more than one\n\t\tmatch an empty string is returned.\n\t\t\"\" or \"%\" can be used for the current buffer, \"#\" for the\n\t\talternate buffer.\n\t\tA full match is preferred, otherwise a match at the start, end\n\t\tor middle of the buffer name is accepted.  If you only want a\n\t\tfull match then put \"^\" at the start and \"$\" at the end of the\n\t\tpattern.\n\t\tListed buffers are found first.  If there is a single match\n\t\twith a listed buffer, that one is returned.  Next unlisted\n\t\tbuffers are searched for.\n\t\tIf the {expr} is a String, but you want to use it as a buffer\n\t\tnumber, force it to be a Number by adding zero to it: >\n\t\t\t:echo bufname(\"3\" + 0)\n<\t\tIf the buffer doesn't exist, or doesn't have a name, an empty\n\t\tstring is returned. >\n\tbufname(\"#\")\t\talternate buffer name\n\tbufname(3)\t\tname of buffer 3\n\tbufname(\"%\")\t\tname of current buffer\n\tbufname(\"file2\")\tname of buffer where \"file2\" matches.",
   "argsType": "[{expr}]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "bufnr",
   "description": "bufnr([{expr} [, {create}]])\n\t\tThe result is the number of a buffer, as it is displayed by\n\t\tthe \":ls\" command.  For the use of {expr}, see |bufname()|\n\t\tabove.\n\t\tIf the buffer doesn't exist, -1 is returned.  Or, if the\n\t\t{create} argument is present and not zero, a new, unlisted,\n\t\tbuffer is created and its number is returned.\n\t\tbufnr(\"$\") is the last buffer: >\n\t\t\t:let last_buffer = bufnr(\"$\")\n<\t\tThe result is a Number, which is the highest buffer number\n\t\tof existing buffers.  Note that not all buffers with a smaller\n\t\tnumber necessarily exist, because \":bwipeout\" may have removed\n\t\tthem.  Use bufexists() to test for the existence of a buffer.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "bufwinid",
   "description": "The result is a Number, which is the |window-ID| of the first\n\t\twindow associated with buffer {expr}.  For the use of {expr},\n\t\tsee |bufname()| above.  If buffer {expr} doesn't exist or\n\t\tthere is no such window, -1 is returned.  Example: >",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "bufwinnr",
   "description": "The result is a Number, which is the number of the first\n\t\twindow associated with buffer {expr}.  For the use of {expr},\n\t\tsee |bufname()| above.  If buffer {expr} doesn't exist or\n\t\tthere is no such window, -1 is returned.  Example: >",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "byte2line",
   "description": "Return the line number that contains the character at byte\n\t\tcount {byte} in the current buffer.  This includes the\n\t\tend-of-line character, depending on the 'fileformat' option\n\t\tfor the current buffer.  The first character has byte count\n\t\tone.\n\t\tAlso see |line2byte()|, |go| and |:goto|.",
   "argsType": "{byte}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "byteidx",
   "description": "Return byte index of the {nr}'th character in the string\n\t\t{expr}.  Use zero for the first character, it then returns\n\t\tzero.\n\t\tThis function is only useful when there are multibyte\n\t\tcharacters, otherwise the returned value is equal to {nr}.\n\t\tComposing characters are not counted separately, their byte\n\t\tlength is added to the preceding base character.  See\n\t\t|byteidxcomp()| below for counting composing characters\n\t\tseparately.\n\t\tExample : >\n\t\t\techo matchstr(str, \".\", byteidx(str, 3))\n<\t\twill display the fourth character.  Another way to do the\n\t\tsame: >\n\t\t\tlet s = strpart(str, byteidx(str, 3))\n\t\t\techo strpart(s, 0, byteidx(s, 1))\n<\t\tAlso see |strgetchar()| and |strcharpart()|.",
   "argsType": "{expr}, {nr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "byteidxcomp",
   "description": "Like byteidx(), except that a composing character is counted\n\t\tas a separate character.  Example: >\n\t\t\tlet s = 'e' . nr2char(0x301)\n\t\t\techo byteidx(s, 1)\n\t\t\techo byteidxcomp(s, 1)\n\t\t\techo byteidxcomp(s, 2)\n<\t\tThe first and third echo result in 3 ('e' plus composing\n\t\tcharacter is 3 bytes), the second echo results in 1 ('e' is\n\t\tone byte).",
   "argsType": "{expr}, {nr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "call()* *E699",
   "description": "Call function {func} with the items in |List| {arglist} as\n\t\targuments.\n\t\t{func} can either be a |Funcref| or the name of a function.\n\t\ta:firstline and a:lastline are set to the cursor line.\n\t\tReturns the return value of the called function.\n\t\t{dict} is for functions with the \"dict\" attribute.  It will be\n\t\tused to set the local variable \"self\". |Dictionary-function|",
   "argsType": "{func}, {arglist} [, {dict}]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "ceil",
   "description": "Return the smallest integral value greater than or equal to\n\t\t{expr} as a |Float| (round up).\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\techo ceil(1.456)\n<\t\t\t2.0  >\n\t\t\techo ceil(-5.456)\n<\t\t\t-5.0  >\n\t\t\techo ceil(4.0)\n<\t\t\t4.0",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "changenr",
   "description": "Return the number of the most recent change.  This is the same\n\t\tnumber as what is displayed with |:undolist| and can be used\n\t\twith the |:undo| command.\n\t\tWhen a change was made it is the number of that change.  After\n\t\tredo it is the number of the redone change.  After undo it is\n\t\tone less than the number of the undone change.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "chanclose",
   "description": "Close a channel or a specific stream associated with it.\n\t\tFor a job, {stream} can be one of \"stdin\", \"stdout\",\n\t\t\"stderr\" or \"rpc\" (closes stdin/stdout for a job started\n\t\twith `\"rpc\":v:true`) If {stream} is omitted, all streams\n\t\tare closed. If the channel is a pty, this will then close the\n\t\tpty master, sending SIGHUP to the job process.\n\t\tFor a socket, there is only one stream, and {stream} should be\n\t\tommited.",
   "argsType": "{id}[, {stream}]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "chansend",
   "description": "Send data to channel {id}. For a job, it writes it to the\n\t\tstdin of the process. For the stdio channel |channel-stdio|,\n\t\tit writes to Nvim's stdout.  Returns the number of bytes\n\t\twritten if the write succeeded, 0 otherwise.\n\t\tSee |channel-bytes| for more information.",
   "argsType": "{id}, {data}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "char2nr",
   "description": "Return number value of the first char in {expr}.  Examples: >\n\t\t\tchar2nr(\" \")\t\treturns 32\n\t\t\tchar2nr(\"ABC\")\t\treturns 65\n\t\t\tchar2nr(\"á\")\t\treturns 225\n\t\t\tchar2nr(\"á\"[0])\t\treturns 195\n\t\t\tchar2nr(\"\\<M-x>\")\treturns 128\n<\t\tNon-ASCII characters are always treated as UTF-8 characters.\n\t\t{utf8} is ignored, it exists only for backwards-compatibility.\n\t\tA combining character is a separate character.\n\t\t|nr2char()| does the opposite.",
   "argsType": "{expr} [, {utf8}]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "charidx",
   "description": "charidx({string}, {idx} [, {countcc}])\n\t\tReturn the character index of the byte at {idx} in {string}.\n\t\tThe index of the first character is zero.\n\t\tIf there are no multibyte characters the returned value is\n\t\tequal to {idx}.\n\t\tWhen {countcc} is omitted or zero, then composing characters\n\t\tare not counted separately, their byte length is added to the\n\t\tpreceding base character.\n\t\tWhen {countcc} is set to 1, then composing characters are\n\t\tcounted as separate characters.\n\t\tReturns -1 if the arguments are invalid or if {idx} is greater\n\t\tthan the index of the last byte in {string}.  An error is\n\t\tgiven if the first argument is not a string, the second\n\t\targument is not a number or when the third argument is present\n\t\tand is not zero or one.\n\t\tSee |byteidx()| and |byteidxcomp()| for getting the byte index\n\t\tfrom the character index.\n\t\tExamples: >\n\t\t\techo charidx('áb́ć', 3)\t\treturns 1\n\t\t\techo charidx('áb́ć', 6, 1)\treturns 4\n\t\t\techo charidx('áb́ć', 16)\t\treturns -1",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "cindent",
   "description": "Get the amount of indent for line {lnum} according the C\n\t\tindenting rules, as with 'cindent'.\n\t\tThe indent is counted in spaces, the value of 'tabstop' is\n\t\trelevant.  {lnum} is used just like in |getline()|.\n\t\tWhen {lnum} is invalid -1 is returned.\n\t\tSee |C-indenting|.",
   "argsType": "{lnum}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "clearmatches",
   "description": "Clears all matches previously defined for the current window\n \t\tby |matchadd()| and the |:match| commands.\n\t\tIf {win} is specified, use the window with this number or\n\t\twindow ID instead of the current window.",
   "argsType": "[{win}]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "col",
   "description": "col({expr})\tThe result is a Number, which is the byte index of the column\n\t\tposition given with {expr}.  The accepted positions are:\n\t\t    .\t    the cursor position\n\t\t    $\t    the end of the cursor line (the result is the\n\t\t\t    number of bytes in the cursor line plus one)\n\t\t    'x\t    position of mark x (if the mark is not set, 0 is\n\t\t\t    returned)\n\t\t    v       In Visual mode: the start of the Visual area (the\n\t\t\t    cursor is the end).  When not in Visual mode\n\t\t\t    returns the cursor position.  Differs from |'<| in\n\t\t\t    that it's updated right away.\n\t\tAdditionally {expr} can be [lnum, col]: a |List| with the line\n\t\tand column number. Most useful when the column is \"$\", to get\n\t\tthe last column of a specific line.  When \"lnum\" or \"col\" is\n\t\tout of range then col() returns zero.\n\t\tTo get the line number use |line()|.  To get both use\n\t\t|getpos()|.\n\t\tFor the screen column position use |virtcol()|.\n\t\tNote that only marks in the current file can be used.\n\t\tExamples: >\n\t\t\tcol(\".\")\t\tcolumn of cursor\n\t\t\tcol(\"$\")\t\tlength of cursor line plus one\n\t\t\tcol(\"'t\")\t\tcolumn of mark t\n\t\t\tcol(\"'\" . markname)\tcolumn of mark markname\n<\t\tThe first column is 1.  0 is returned for an error.\n\t\tFor an uppercase mark the column may actually be in another\n\t\tbuffer.\n\t\tFor the cursor position, when 'virtualedit' is active, the\n\t\tcolumn is one higher if the cursor is after the end of the\n\t\tline.  This can be used to obtain the column in Insert mode: >\n\t\t\t:imap <F2> <C-O>:let save_ve = &ve<CR>\n\t\t\t\t\\<C-O>:set ve=all<CR>\n\t\t\t\t\\<C-O>:echo col(\".\") . \"\\n\" <Bar>\n\t\t\t\t\\let &ve = save_ve<CR>\n<",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "complete()* *E785",
   "description": "Set the matches for Insert mode completion.\n\t\tCan only be used in Insert mode.  You need to use a mapping\n\t\twith CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O\n\t\tor with an expression mapping.\n\t\t{startcol} is the byte offset in the line where the completed\n\t\ttext start.  The text up to the cursor is the original text\n\t\tthat will be replaced by the matches.  Use col('.') for an\n\t\tempty string.  \"col('.') - 1\" will replace one character by a\n\t\tmatch.\n\t\t{matches} must be a |List|.  Each |List| item is one match.\n\t\tSee |complete-items| for the kind of items that are possible.\n\t\tNote that the after calling this function you need to avoid\n\t\tinserting anything that would cause completion to stop.\n\t\tThe match can be selected with CTRL-N and CTRL-P as usual with\n\t\tInsert mode completion.  The popup menu will appear if\n\t\tspecified, see |ins-completion-menu|.\n\t\tExample: >\n\tinoremap <F5> <C-R>=ListMonths()<CR>",
   "argsType": "{startcol}, {matches}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "complete_add",
   "description": "Add {expr} to the list of matches.  Only to be used by the\n\t\tfunction specified with the 'completefunc' option.\n\t\tReturns 0 for failure (empty string or out of memory),\n\t\t1 when the match was added, 2 when the match was already in\n\t\tthe list.\n\t\tSee |complete-functions| for an explanation of {expr}.  It is\n\t\tthe same as one item in the list that 'omnifunc' would return.",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "complete_check",
   "description": "Check for a key typed while looking for completion matches.\n\t\tThis is to be used when looking for matches takes some time.\n\t\tReturns |TRUE| when searching for matches is to be aborted,\n\t\tzero otherwise.\n\t\tOnly to be used by the function specified with the\n\t\t'completefunc' option.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "complete_info",
   "description": "complete_info([{what}])\n\t\tReturns a Dictionary with information about Insert mode\n\t\tcompletion.  See |ins-completion|.\n\t\tThe items are:\n\t\t   mode\t\tCurrent completion mode name string.\n\t\t\t\tSee |complete_info_mode| for the values.\n\t\t   pum_visible\t|TRUE| if popup menu is visible.\n\t\t\t\tSee |pumvisible()|.\n\t\t   items\tList of completion matches.  Each item is a\n\t\t\t\tdictionary containing the entries \"word\",\n\t\t\t\t\"abbr\", \"menu\", \"kind\", \"info\" and \"user_data\".\n\t\t\t\tSee |complete-items|.\n\t\t   selected\tSelected item index.  First index is zero.\n\t\t\t\tIndex is -1 if no item is selected (showing\n\t\t\t\ttyped text only)\n\t\t   inserted\tInserted string. [NOT IMPLEMENT YET]",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "value",
   "name": "complete_info_mode",
   "description": "mode values are:\n\t\t   \"\"\t\t     Not in completion mode\n\t\t   \"keyword\"\t     Keyword completion |i_CTRL-X_CTRL-N|\n\t\t   \"ctrl_x\"\t     Just pressed CTRL-X |i_CTRL-X|\n\t\t   \"whole_line\"\t     Whole lines |i_CTRL-X_CTRL-L|\n\t\t   \"files\"\t     File names |i_CTRL-X_CTRL-F|\n\t\t   \"tags\"\t     Tags |i_CTRL-X_CTRL-]|\n\t\t   \"path_defines\"    Definition completion |i_CTRL-X_CTRL-D|\n\t\t   \"path_patterns\"   Include completion |i_CTRL-X_CTRL-I|\n\t\t   \"dictionary\"\t     Dictionary |i_CTRL-X_CTRL-K|\n\t\t   \"thesaurus\"\t     Thesaurus |i_CTRL-X_CTRL-T|\n\t\t   \"cmdline\"\t     Vim Command line |i_CTRL-X_CTRL-V|\n\t\t   \"function\"\t     User defined completion |i_CTRL-X_CTRL-U|\n\t\t   \"omni\"\t     Omni completion |i_CTRL-X_CTRL-O|\n\t\t   \"spell\"\t     Spelling suggestions |i_CTRL-X_s|\n\t\t   \"eval\"            |complete()| completion\n\t\t   \"unknown\"\t     Other internal modes",
   "valuetype": "any"
  },
  {
   "type": "func",
   "name": "confirm",
   "description": "confirm({msg} [, {choices} [, {default} [, {type}]]])\n\t\tConfirm() offers the user a dialog, from which a choice can be\n\t\tmade.  It returns the number of the choice.  For the first\n\t\tchoice this is 1.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "copy",
   "description": "copy({expr})\tMake a copy of {expr}.  For Numbers and Strings this isn't\n\t\tdifferent from using {expr} directly.\n\t\tWhen {expr} is a |List| a shallow copy is created.  This means\n\t\tthat the original |List| can be changed without changing the\n\t\tcopy, and vice versa.  But the items are identical, thus\n\t\tchanging an item changes the contents of both |Lists|.\n\t\tA |Dictionary| is copied in a similar way as a |List|.\n\t\tAlso see |deepcopy()|.",
   "argsType": "",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "cos",
   "description": "Return the cosine of {expr}, measured in radians, as a |Float|.\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo cos(100)\n<\t\t\t0.862319 >\n\t\t\t:echo cos(-4.01)\n<\t\t\t-0.646043",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "cosh",
   "description": "Return the hyperbolic cosine of {expr} as a |Float| in the range\n\t\t[1, inf].\n\t\t{expr} must evaluate to a |Float| or a |Number|.\n\t\tExamples: >\n\t\t\t:echo cosh(0.5)\n<\t\t\t1.127626 >\n\t\t\t:echo cosh(-0.5)\n<\t\t\t-1.127626",
   "argsType": "{expr}",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "count",
   "description": "Return the number of times an item with value {expr} appears\n\t\tin |String|, |List| or |Dictionary| {comp}.",
   "argsType": "{comp}, {expr} [, {ic} [, {start}]]",
   "returnType": "string"
  },
  {
   "type": "func",
   "name": "cscope_connection",
   "description": "cscope_connection([{num} , {dbpath} [, {prepend}]])\n\t\tChecks for the existence of a |cscope| connection.  If no\n\t\tparameters are specified, then the function returns:\n\t\t\t0, if cscope was not available (not compiled in), or\n\t\t\t   if there are no cscope connections;\n\t\t\t1, if there is at least one cscope connection.",
   "argsType": "",
   "returnType": "string"
  }
 ]
}